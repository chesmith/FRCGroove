@using FRCGroove.Lib.Models
@using FRCGroove.Lib
@using FRCGroove.Lib.Models.Statboticsv2
@using FRCGroove.Lib.Models.Groove
@using FRCGroove.Web.Models
@using System.Text.RegularExpressions;
@model FRCGroove.Web.Models.Dashboard

@{
    string eventName = string.Empty;
    if (Model != null && Model.Event != null)
    {
        eventName = $" - {Model.Event.name}";
    }
    ViewBag.Title = $"FRC Groove{eventName}";
}

@{
    var eventCode = "Invalid";
    if (Model != null && Model.Event != null && Model.EventState != EventState.Invalid)
    {
        eventCode = Model.Event.key;
    }
}

<style>
    dialog::backdrop {
        background-color: hsl(0, 0%, 0%, 0.5)
    }

    dialog {
        padding: 0.5em;
        border-radius: 1rem;
    }
</style>

@Html.Partial("Navigation", "Matches")

@if (Model != null)
{
    <div class="card" style="border-bottom-left-radius:0;border-bottom-right-radius:0">
        @if (Model.Event != null)
        {
            <div class="card-header fixed-top" style="margin-bottom: 0; padding: 0.5rem;" onclick="$('html, body').animate({ scrollTop: 0 }, 250);">
                <h6 style="margin-bottom:0">@Model.Event.name</h6>
                <div style="width:100%; font-size:0.75rem; position: relative">
                    <span style="float:left">@Model.Event.dateStart.ToString("ddd M/d") to @Model.Event.dateEnd.ToString("ddd M/d")</span>
                    <span id="filterToggle" style="float:right; position: absolute; top: -10px; right: 15px"><a class="fas fa-filter fa-lg" style="color:white" onclick="toggleFilter()" )"></a></span>
                </div>
            </div>
        }

        <ul class="list-group list-group-flush" style="margin-top: 45px">
            <li class="list-group-item" id="filterSection" style="padding:0.5rem 0.75rem 0.5rem 0.75rem; display:none">
                <div class="input-group">
                    <div class="input-group-prepend"><button id="filterReset" class="btn btn-secondary" type="reset">Reset</button></div>
                    <input id="filterValue" type="number" pattern="[0-9]*" class="form-control" placeholder="Team #" maxlength="4">
                    <div class="input-group-append"><button id="filterSubmit" class="btn btn-primary" type="submit">Filter</button></div>
                </div>
            </li>
            @{/*** Event status ***/}
            <li class="list-group-item" style="padding:0.5rem 0.75rem 0.5rem 0.75rem">
                @{
                    string eventStatus = string.Empty;
                }
                @if (Model.EventState == EventState.Past)
                {
                    eventStatus = "Event is complete (<a href='#Playoffs'>playoffs</a>)";// "/ <a href='#Brackets'>brackets</a>)";
                }
                else if (Model.EventState == EventState.Future)
                {
                    eventStatus = "Match schedule not yet available";
                }
                else if (Model.EventState == EventState.Invalid)
                {
                    eventStatus = "This appears to be an invalid event code<br />(<a href='/'>return to event listing</a>)";
                }
                else
                {
                    // TODO: broaden event states and move most of this logic backend
                    if (Model.EventState == EventState.Qualifications && Model.Matches != null
                     && Model.Matches.Count(m => m.competitionLevel == "Qualification" && m.alliances["blue"].score != -1) == 0)
                    {
                        eventStatus = "Qualifications haven't started";
                    }
                    else if (
                        (Model.EventState == EventState.Qualifications && Model.Matches != null
                          && Model.Matches.Count(m => m.competitionLevel == "Qualification" && m.alliances["blue"].score == -1) == 0)
                        ||
                        (Model.EventState == EventState.Playoffs && Model.Matches != null
                          && Model.Matches.Count(m => m.competitionLevel == "Playoff" && m.alliances["blue"].score != -1) == 0))
                    {
                        eventStatus = "Qualifications have completed - waiting for playoffs to begin";
                        if (Model.Matches.Count(m => m.competitionLevel == "Playoff") > 0)
                        { eventStatus += "<span>(<a href='#nextmatch'>next match</a>)</span>"; }
                    }
                    else if (Model.EventState == EventState.Qualifications
                          || Model.EventState == EventState.Playoffs
                          || Model.EventState == EventState.Finals)
                    {
                        int scheduleOffset = (int)Math.Round(Model.ScheduleOffset, 0);
                        if (scheduleOffset == 0)
                        {
                            eventStatus = $"{Model.EventState.ToString()} seem to be running on time (<a href='#nextmatch'>next match</a>)";
                        }
                        else
                        {
                            string offsetColor = (scheduleOffset > 0 ? "#7c0a0a" : "#046705");
                            string offsetBehindAhead = (scheduleOffset > 0 ? "behind" : "ahead");
                            eventStatus = $"<span style='font -style:italic; color:{offsetColor};'>{Model.EventState.ToString()} are running about {Math.Abs(scheduleOffset)} minute{(Math.Abs(scheduleOffset) > 1 ? "s" : "")} {offsetBehindAhead} (<a href='#nextmatch'>next match</a>)</span>";
                        }
                    }
                }
                <span id="eventStatus">@Html.Raw(eventStatus)</span>
            </li>

            @{/*** Team watchlist ***/}
            <li class="list-group-item" style="padding:0.5rem 0.75rem 0.5rem 0.75rem">
                @{
                    bool tapHint = true;
                    if (Model.EventState != EventState.Future && !(Model.EventState == EventState.Qualifications && Model.Matches.Count(m => m.hasStarted) == 0))
                    {
                        tapHint = (Model.TeamsOfInterest.Count == 0 && Model.EventState != EventState.Future && Model.EventState != EventState.Invalid);
                    }
                }

                <span id="tapHint" style="font-size:0.75rem; display:@(tapHint ? "inline" : "none")"><i>Tap team numbers to add/remove to watchlist once matches start</i></span>

                <div id="teamSort" style="display:none">
                    <span id="teamSortLinks">
                        <a href="javascript:;">Rank</a> <i id="sortRank" class="fas fa-sort-up" style="display:inline"></i> |
                        <a href="javascript:;">OPR</a> <i id="sortOPR" style="display:none"></i> |
                        <a href="javascript:;">DPR</a> <i id="sortDPR" style="display:none"></i> |
                        <a href="javascript:;">CCWM</a> <i id="sortCCWM" style="display:none"></i>
                    </span>
                    <span id="watchlistLabel" style="display:none"><i>Team watchlist</i></span>
                    <i id="watchlistToggle" class="fas fa-minus" style="display:inline; float:right" onclick="toggleWatchlist()"></i>
                </div>

                <div id="watchlist" style="height:@(Model.EventState != EventState.Future && !(Model.Matches != null && Model.Matches.Count(m => m.hasStarted) == 0) ? Model.TeamsOfInterest.Count * 47 : 0)px"></div>

                <script type="text/javascript">
                    function toggleWatchlist() {
                        $("#watchlist").toggle('fast', function () {
                            $("#watchlistLabel").toggle();
                            $("#teamSortLinks").toggle();
                            let visible = $("#watchlist").is(":visible");
                            if (visible)
                                $("#watchlistToggle").attr("class", "fas fa-minus");
                            else
                                $("#watchlistToggle").attr("class", "fas fa-plus");
                        });
                    }

                    var loadTime = new Date();

                    var eventState = "@Model.EventState";
                    var matches = @(Model.Matches == null ? 0 : Model.Matches.Count(m => m.hasStarted));

                    var teamList = "@string.Join(",", Model.TeamsOfInterest.Select(t => t.number))";
                    var sortName = "Rank";
                    var prevSortName = "Rank";
                    var sortDirection = "ASC";
                    $(function () {
                        RefreshWatchlist();
                    });
                    $("body").on("click", "#teamSort a", function () {
                        sortName = $(this).html();
                        if (sortName == prevSortName)
                            sortDirection = sortDirection == "ASC" ? "DESC" : "ASC";
                        else if (sortName == "Rank")
                            sortDirection = "ASC";
                        else
                            sortDirection = "DESC";
                        RefreshWatchlist();
                        prevSortName = sortName;
                    });
                    function RefreshWatchlist() {
                        $.ajax({
                            type: "POST",
                            url: "/FRCEvent/TeamsOfInterestAjax",
                            data: '{"eventCode": "@eventCode", "teamList": "' + teamList + '", "sortName": "' + sortName + '", "sortDirection": "' + sortDirection + '"}',
                            contentType: "application/json; charset=utf-8",
                            dataType: "json",
                            success: LoadWatchlist,
                            failure: function (response) {
                                OnFailure();
                                console.log("failed to get teams: " + response.d);
                            },
                            error: function (response) {
                                OnFailure();
                                console.log("error getting teams: " + response.d);
                            }
                        });
                    };
                    function LoadWatchlist(response) {
                        var model = response;
                        $("#watchlist").empty();
                        //$("#watchlist").removeAttr("style");
                        $("#watchlist").css("height", "");
                        $.each(model, function () {
                            var team = this;
                            if (team.eventRank > -1)
                            {
                                var teamListing = '<div style="margin-top:0.5rem">';
                                teamListing += '<div>' + team.number + ' ' + team.name;
                                teamListing += ' (<span><a href="https://www.thebluealliance.com/event/@eventCode#rankings" target="_blank" rel="noopener noreferrer">#' + team.eventRank + '</a></span>) ';
                                teamListing += '<sup style="font-size:small; cursor:pointer" onclick="javascript:ToggleWatch(' + team.number + ');">[<span style="color:red">x</span>]</sup></div>';
                                if (team.Stats != null) {
                                    teamListing += '<div style="font-size:11px;">OPR: ' + team.Stats.OPR + ', DPR: ' + team.Stats.DPR + ', CCWM: ' + team.Stats.CCWM + '</div></div>';
                                }
                                $("#watchlist").append(teamListing);
                            }
                        });

                        $("[id^=sort]").each(function () { $(this).removeAttr("class") });
                        $("[id^=sort]").each(function () { $(this).attr("style", "display:none") });

                        if (sortDirection == "ASC")
                            $("#sort" + sortName).attr("class", "fas fa-sort-up");
                        else
                            $("#sort" + sortName).attr("class", "fas fa-sort-down");
                        $("#sort" + sortName).attr("style", "display:inline");

                        var teams = teamList.split(",");
                        var teamsToKeep = [];
                        $.each(teams, function (index, value) {
                            if (value.indexOf("x") == -1) {
                                teamsToKeep.push(value);
                            }
                        });
                        teamsToKeep.sort((a, b) => parseInt(a) - parseInt(b));
                        teamList = teamsToKeep.join(",");

                        if (eventState != "Future" && !(eventState == "Qualifications" && matches == 0)) {
                            if (teamList.length > 0 && TeamsInThisEvent(teamList) > 0) {
                                $("#teamSort").css("display", "inline");
                                $("#tapHint").css("display", "none");
                            }
                            else {
                                $("#teamSort").css("display", "none");
                                $("#tapHint").css("display", "inline");
                            }
                        }
                    };
                    function OnFailure() {
                        $("#watchlist").empty();
                        $("#watchlist").removeAttr("style");
                        $("#watchlist").append('<span style="color:darkred;font-style:italic">Unable to retrive watchlist</span>');
                    };
                    function TeamsInThisEvent(list) {
                        var teams = list.split(',');
                        var count = 0;
                        $.each(teams, function (index, teamNumber) {
                            if ($("[id^=tm" + teamNumber + "-]").length > 0) {
                                count++;
                            }
                        });
                        return count;
                    };
                    //function PromptForRefresh() {
                    //    var elapsed = new Date() - loadTime;
                    //    if (elapsed > 600000) {
                    //        $("#refresh a").css("font-size", "1.25rem").css("color", "red");
                    //        clearInterval(refreshPrompt);
                    //    } else if (elapsed > 300000) {
                    //        $("#refresh").attr("class", "animate-flicker");
                    //    }
                    //}
                </script>
            </li>
        </ul>
    </div>
}

<div style="margin-top: 0px">
    <table id="tableMatches" style="width: 100%">
        @if (Model != null && Model.Matches != null && Model.Matches.Count > 1)
        {
            //Boolean inFuture = false;
            DateTime currentDate = DateTime.MinValue;
            //var day1 = Model.TBAMatches.Where(m => m.timeDT.Date == Model.TBAMatches[0].timeDT.Date).ToList();
            //var day2 = Model.TBAMatches.Where(m => m.timeDT.Date == Model.TBAMatches[0].timeDT.Date.AddDays(1)).ToList();
            //var day2Date = DateTime.MinValue;
            //if (day2 != null && day2.Count > 0) { day2Date = day2[0].timeDT.Date; }
            //int? day2FirstMatch = day2[0]?.match_number;
            int nextmatch = -1;
            for (int i = Model.Matches.Count - 1; i > -1; i--)
            {
                if (Model.Matches[i].hasStarted)
                {
                    nextmatch = i + 1;
                    break;
                }
            }
            for (int i = 0; i < Model.Matches.Count; i++)
            {
                GrooveMatch match = Model.Matches[i];
                string matchKey = match.competitionLevel + match.setNumber.ToString().PadLeft(2, '0') + match.matchNumber.ToString().PadLeft(3, '0');
                if (match.setNumber == 1 && match.matchNumber == 1)
                {
                    <tr><td colspan="5" style="padding: 0; background: #5151a8; padding: 5px 10px; position: relative; z-index: 1; color: #fff; font-weight: bold;"><a name="@(match.competitionLevel)s"></a>@(match.competitionLevel)s</td></tr>
                }

                if (match.timeScheduled.Date > currentDate)
                {
                    if (currentDate > DateTime.MinValue)
                    {
                        <tr><td colspan="5" style="height: 3px; border-top-style: dashed"></td></tr>
                    }
                    currentDate = match.timeScheduled.Date;
                }

                //TODO: hacked together solution - If they skipped a match (e.g. needs to be replayed later), this was putting the "next match" header in the wrong place
                //if (match.actual_time == 0 && !inFuture)
                if (i == nextmatch)
                {
                    //inFuture = true;
                    <tr id="nextmatch"><td colspan="5" style="color: white; background-color: #666699; text-align: left; font-size: small;"><a name="nextmatch"></a>&nbsp;next match &#8628;</td></tr>
                }

                /*** Match score row ***/

                Dictionary<int, string> teamClasses = new Dictionary<int, string>();
                Dictionary<int, string> teamActions = new Dictionary<int, string>();

                foreach (string teamKey in match.alliances["red"].teamKeys)
                {
                    List<string> classes = new List<string>();
                    //TODO: Int32.Parse on mix alphanumeric (typically offseason)
                    int teamNumber = Int32.Parse(Regex.Replace(teamKey, "[^0-9,-]+", ""));
                    if (Model.TeamsOfInterest.Count(t => t.number == teamNumber) > 0)
                    {
                        classes.Add("redHighlight");
                        teamActions[teamNumber] = "remove";
                    }
                    else { teamActions[teamNumber] = "add"; }

                    if (match.alliances["red"].dqTeamKeys.Contains(teamKey)) { classes.Add("disqualified"); }

                    if (match.alliances["red"].surrogateTeamKeys.Contains(teamKey)) { classes.Add("surrogate"); }

                    if (classes.Count > 0)
                    { teamClasses[teamNumber] = " class=\"" + String.Join(" ", classes) + "\""; }
                    else
                    { teamClasses[teamNumber] = string.Empty; }
                }

                foreach (string teamKey in match.alliances["blue"].teamKeys)
                {
                    List<string> classes = new List<string>();
                    //TODO: Int32.Parse on mix alphanumeric (typically offseason)
                    int teamNumber = Int32.Parse(Regex.Replace(teamKey, "[^0-9,-]+", ""));
                    if (Model.TeamsOfInterest.Count(t => t.number == teamNumber) > 0)
                    {
                        classes.Add("blueHighlight");
                        teamActions[teamNumber] = "remove";
                    }
                    else { teamActions[teamNumber] = "add"; }

                    if (match.alliances["blue"].dqTeamKeys.Contains(teamKey)) { classes.Add("disqualified"); }

                    if (match.alliances["blue"].surrogateTeamKeys.Contains(teamKey)) { classes.Add("surrogate"); }

                    if (classes.Count > 0)
                    { teamClasses[teamNumber] = " class=\"" + String.Join(" ", classes) + "\""; }
                    else
                    { teamClasses[teamNumber] = string.Empty; }
                }

                //TODO: Int32.Parse on mix alphanumeric (typically offseason)
                List<int> redAlliance = match.alliances["red"].teamKeys.Select(v => Int32.Parse(v.Substring(3))).ToList();
                List<int> blueAlliance = match.alliances["blue"].teamKeys.Select(v => Int32.Parse(v.Substring(3))).ToList();

                <tr id="@matchKey-r">
                    <td id="@matchKey-title" style="text-align: center">
                        <div><a href="@match.matchDetailsUrl">
                            @if (match.title.Contains("Bracket"))
                            {
                                @Html.Raw(match.title.Replace("Bracket ", "Bracket<br/>"))
                            }
                            else
                            {
                                @match.title
                            }
                        </a></div>
                        <div id="@matchKey-time" style="font-size: x-small">
                            @if (match.hasStarted)
                            {
                                <span>@match.timeScheduled.ToString("ddd M/d h:mm") (@match.timeActual.ToString("h:mm"))</span>
                            }
                            else if (Model.EventState != EventState.Future)
                            {
                                double offset = Model.ScheduleOffset;
                                //if (match.match_number > day2FirstMatch && DateTime.Now.Date < day2Date) { offset = 0; }
                                if (match.timeScheduled.Date > DateTime.Now.Date) { offset = 0; }
                                <span>@match.timeScheduled.ToString("ddd M/d h:mm") <i>(est. @match.timeScheduled.AddMinutes(offset).ToString("h:mm"))</i></span>
                            }
                        </div>
                    </td>
                    <td id="@matchKey-ar" class="red">
                        <a name="@(match.competitionLevel + match.matchNumber)"></a>
                        @if (redAlliance != null && redAlliance.Count > 0)
                        {
                            @TeamListing(redAlliance[0], match, teamClasses, teamActions)
                            @TeamListing(redAlliance[1], match, teamClasses, teamActions)
                            @TeamListing(redAlliance[2], match, teamClasses, teamActions)
                        }
                    </td>
                    @ScoreBreakdown(match)
                    <td id="@matchKey-ab" class="blue">
                        @if (blueAlliance != null && blueAlliance.Count > 0)
                        {
                            @TeamListing(blueAlliance[0], match, teamClasses, teamActions)
                            @TeamListing(blueAlliance[1], match, teamClasses, teamActions)
                            @TeamListing(blueAlliance[2], match, teamClasses, teamActions)
                        }
                    </td>
                </tr>
            }

            @*<p style="font-size: 0.75rem; font-style:italic; margin-top: 0.5rem"><span style="color:red">*</span> Times should be local to the event and estimates are calculated to best of our ability - trust what you see and hear on-site.</p>*@
        }
    </table>
    <dialog id="predictionDialog">
        <span id="prediction"></span>
    </dialog>
</div>

@if (Model.Bracket != null && (Model.EventState == EventState.Playoffs || Model.EventState == EventState.Finals || Model.EventState == EventState.Past) && eventCode != "CMPTX")
{
    <div style="margin-top: 15px">
        @Html.Partial("PlayoffBrackets", Model)
    </div>
}

@helper ScoreBreakdown(GrooveMatch match)
{
    int totalRed = 0;
    int predictedRed = match.alliances["red"].predictedPoints;
    string rpRed;
    int totalBlue = 0;
    int predictedBlue = match.alliances["blue"].predictedPoints;
    string rpBlue;

    string matchKey = match.competitionLevel + match.setNumber.ToString().PadLeft(2, '0') + match.matchNumber.ToString().PadLeft(3, '0');

    if (match.hasStarted && match.alliances["red"].score != -1)
    {
        totalRed = match.alliances["red"].totalPoints;
        rpRed = String.Concat(Enumerable.Repeat(".", match.alliances["red"].rp));

        totalBlue = match.alliances["blue"].totalPoints;
        rpBlue = String.Concat(Enumerable.Repeat(".", match.alliances["blue"].rp));

        <td id="@matchKey-sr" style="position:relative" class="@((match.winningAlliance == "red") ? "redHighlight" : "red")" onClick="showDialog('@match.title<br />Predicted @predictedRed-@predictedBlue')">
            <span id="@matchKey-ssr">@Html.Raw(totalRed) @((predictedRed > predictedBlue) ? "*":"")</span>
            <span id="@matchKey-rpr" style="font-weight: bold; letter-spacing: 2px; position:absolute; bottom: 0; left: 1px">&nbsp;@rpRed</span>
        </td>
        <td id="@matchKey-sb" style="position:relative" class="@((match.winningAlliance == "blue") ? "blueHighlight" : "blue")" onClick="showDialog('@match.title<br />Predicted @predictedRed-@predictedBlue')">
            <span id="@matchKey-ssb">@Html.Raw(totalBlue) @((predictedRed < predictedBlue) ? "*":"")</span>
            <span id="@matchKey-rpb" style="font-weight: bold; letter-spacing: 2px; position: absolute; bottom: 0; left: 1px">&nbsp;@rpBlue</span>
        </td>
    }
    else if (predictedRed > 0 || predictedBlue > 0)
    {
        <td id="@matchKey-sr" style="position:relative" class="@((predictedRed > predictedBlue) ? "redHighlightPredict" : "red")">
            <span id="@matchKey-ssr">(@Html.Raw(predictedRed))</span>
            <span id="@matchKey-rpr" style="font-weight: bold; letter-spacing: 2px; position:absolute; bottom: 0; left: 1px">&nbsp;</span>
        </td>
        <td id="@matchKey-sb" style="position:relative" class="@((predictedRed < predictedBlue) ? "blueHighlightPredict" : "blue")">
            <span id="@matchKey-ssb">(@Html.Raw(predictedBlue))</span>
            <span id="@matchKey-rpb" style="font-weight: bold; letter-spacing: 2px; position:absolute; bottom: 0; left: 1px">&nbsp;</span>
        </td>
    }
    else
    {
        <td id="@matchKey-sr" style="position:relative"><span id="@matchKey-ssr"></span><span id="@matchKey-rpr" style="font-weight: bold; letter-spacing: 2px; position:absolute; bottom: 0; left: 1px">&nbsp;</span></td>
        <td id="@matchKey-sb" style="position:relative"><span id="@matchKey-ssb"></span><span id="@matchKey-rpb" style="font-weight: bold; letter-spacing: 2px; position:absolute; bottom: 0; left: 1px">&nbsp;</span></td>
    }
}

@helper TeamListing(int teamNumber, GrooveMatch match, Dictionary<int, string> classes, Dictionary<int, string> actions)
{
    if (teamNumber > 0)
    {
        double epa = StatboticsAPIv2.EPACache.Where(t => t.Key == teamNumber).Select(e => e.Value.epa_end.Value).FirstOrDefault();
        string epaString = string.Empty;
        if (epa > 0) { epaString = $" [{epa}]"; }
        <div id="tm@(teamNumber)-@(match.competitionLevel)-@(match.matchNumber)" @Html.Raw(classes[teamNumber])>
            <span id="tmNum@(teamNumber)">@teamNumber</span>
            @if (Model.EventRankings.ContainsKey(teamNumber))
            {
                <span class="teamRank" id="rank@(teamNumber)-@(match.competitionLevel)-@(match.matchNumber)"> (#@Model.EventRankings[teamNumber].rank)</span>
            }
            <span class="teamName">@(Groove.TeamListingCache.ContainsKey(teamNumber) ? Groove.TeamListingCache[teamNumber].name : "")@epaString</span>
        </div>
    }
}

<script type="text/javascript">
    $(document).ready(function () {
        $("[id^=tm]").click(function () {
            var id = $(this).attr('id');
            var teamNumber = id.substring(2, id.indexOf('-'));
            ToggleWatch(teamNumber)
        });

        $("#filterValue").keyup(function () {
            processFilter();
            return false;
        });

        $("#filterSubmit").on('click', function () {
            processFilter();
            return false;
        });

        $('#filterReset').on('click', function (e) {
            resetFilter();
        });

        const dialog = document.getElementById("predictionDialog");
        dialog.addEventListener("click", e => {
            dialog.close();
        })
    });

    function toggleFilter() {
        $('#filterSection').toggle('fast', function () {
            if (!$('#filterSection').is(':visible')) {
                resetFilter();
            }
        });
    }

    //////// working on staying at same position when changing orientation
    //let scrollPosn = 0;

    //$("selector").get(0).scrollIntoView({behavior: 'smooth'});
    //document.getElementById("element-id").scrollIntoView();

    //$(window).on("orientationchange", function (event) {
    //    console.log(event.target.screen.orientation.type);

    //    for (let i = 1; int < 100; i++) {
    //        let matchKey = "qm" +
    //        if($("#" + "" + "")

    ////$("selector").get(0).scrollIntoView({behavior: 'smooth'});
    //    }
    //});

    //$(window).scroll(function () {
    //    scrollPosn = $(this).scrollTop();
    //});

    //$(window).resize(function () {
    //    console.log("resize:" + $(this).scrollTop());
    //    $("html, body").animate({ scrollTop: scrollPosn }, 0);
    //});

    //function isInViewport(element) {
    //    var top_of_element = element.offset().top;
    //    var bottom_of_element = element.offset().top + element.outerHeight();
    //    var bottom_of_screen = $(window).scrollTop() + $(window).innerHeight();
    //    var top_of_screen = $(window).scrollTop();

    //    return ((bottom_of_screen > top_of_element) && (top_of_screen < bottom_of_element));
    //}
    /////////////

    function ToggleWatch(teamNumber) {
        var entries = $("[id^=tm" + teamNumber + "-]");
        var action = '';
        $.each(entries, function () {
            var weight = $(this).css('font-weight');
            if (weight == 400) {
                var color = $(this).css('color');
                if (color.startsWith('rgb(255'))
                    color = 'red';
                else
                    color = 'blue';
                $(this).addClass(color + 'Highlight');
                $(this).css('font-weight', '700');
                action = 'add';
            }
            else {
                var color = $(this).css('background-color');
                if (color.startsWith('rgb(255'))
                    color = 'red';
                else
                    color = 'blue';
                $(this).removeClass(color + 'Highlight');
                $(this).css('font-weight', '400');
                action = 'remove';
            }
        });

        if (action == 'add') {
            if (teamList.length > 0) teamList += ",";
            teamList += teamNumber;
            if (eventState != "Future" && matches > 0) {
                var h = $("#watchlist").height();
                $("#watchlist").height(h + 47);
            }
        }
        else
            teamList = teamList.replace(teamNumber, "x" + teamNumber);

        RefreshWatchlist();
    }

    function updateEventData() {
        $.get("/FRCEvent/GetDashboardData?eventCode=@eventCode", function (m) {
            let refresh = false;
            if (!$("#Qualification01001-r").length) {
                console.log("no qm1");
                refresh = true;
            } else if (m.Matches[m.Matches.length - 1].competitionLevel == "Playoff" && !$("#Playoff01001-r").length) {
                console.log("no sf1");
                refresh = true;
            } else if (m.Matches[m.Matches.length - 1].competitionLevel == "Final" && !$("#Final01001-r").length) {
                console.log("no f1");
                refresh = true;
            }
            if (refresh) location.reload();

            $("#nextmatch").remove();
            let nextmatch = "";
            for (let i = m.Matches.length - 1; i > -1; i--) {
                if (m.Matches[i].hasStarted) {
                    if (i == m.Matches.length - 1) break; // comp is done
                    nextmatch = m.Matches[i + 1].competitionLevel + m.Matches[i + 1].setNumber.toString().padStart(2, '0') + m.Matches[i + 1].matchNumber.toString().padStart(3, '0');
                    break;
                }
            }
            $.each(m.Matches, function (key, match) {
                var matchKey = match.competitionLevel + match.setNumber.toString().padStart(2, '0') + match.matchNumber.toString().padStart(3, '0');

                if (matchKey == nextmatch) {
                    inFuture = true;
                    $("#" + matchKey + "-r").before('<tr id="nextmatch"><td colspan="5" style="color: white; background-color: #666699; text-align: left; font-size: small; "><a name="nextmatch"></a>&nbsp;next match &#8628;</td></tr>');
                }
                updateMatchTime(match, m.EventState, m.ScheduleOffset);
                scoreBreakdown(match);
            });
            updateTeamStats(m.EventRankings);
            RefreshWatchlist();
            updateEventStatus(m.EventState, m.Matches, m.ScheduleOffset);
        });
    }

    function updateTeamStats(rankings) {
        $.each(rankings, function (key, ranking) {
            $("[id^=rank" + key + "]").html(" (#" + ranking.rank + ")");
        });
    }

    function scoreBreakdown(match)
    {
        @{/* TODO: This assumes the table exists - need to handle use case where the page was loaded before match schedule was released */}
        @{/* TODO: This won't add playoffs once those have begun - requires a page refresh - detect if the row doesn't exist and add it */}
        let predictedRed = match.alliances["red"].predictedPoints;
        let predictedBlue = match.alliances["blue"].predictedPoints;

        var matchKey = match.competitionLevel + match.setNumber.toString().padStart(2, '0') + match.matchNumber.toString().padStart(3, '0');

        if (match.hasStarted && match.alliances["red"].score > -1)
        {
            let totalRed = match.alliances["red"].totalPoints;
            let rpRed = ".".repeat(match.alliances["red"].rp);

            let totalBlue = match.alliances["blue"].totalPoints;
            let rpBlue = ".".repeat(match.alliances["blue"].rp);

            $("#" + matchKey + "-ssr").html(`${totalRed} ${((predictedRed > predictedBlue) ? "*" : "")}`);
            $("#" + matchKey + "-rpr").html(`&nbsp;${rpRed}`);
            $("#" + matchKey + "-ssb").html(`${totalBlue} ${((predictedRed < predictedBlue) ? "*" : "")}`);
            $("#" + matchKey + "-rpb").html(`&nbsp;${rpBlue}`);

            $("#" + matchKey + "-sr").attr('class', `${((match.winningAlliance == "red") ? "redHighlight" : "red")}`);
            $("#" + matchKey + "-sb").attr('class', `${((match.winningAlliance == "blue") ? "blueHighlight" : "blue")}`);

            $("#" + matchKey + "-sr").removeAttr('onclick').off('click').on('click', function () {
                showDialog(`${match.title}<br />Predicted ${predictedRed}-${predictedBlue}`);
            });
            $("#" + matchKey + "-sb").removeAttr('onclick').off('click').on('click', function () {
                showDialog(`${match.title}<br />Predicted ${predictedRed}-${predictedBlue}`);
            });
        }
        else if (predictedRed > 0 || predictedBlue > 0)
        {
            // TODO: assume the team numbers haven't been populated (e.g. playoffs)

            $("#" + matchKey + "-ar");
            $("#" + matchKey + "-ab");

            $("#" + matchKey + "-ssr").html(`(${predictedRed})`);
            $("#" + matchKey + "-ssb").html(`(${predictedBlue})`);

            $("#" + matchKey + "-sr").attr('class', `${((predictedRed > predictedBlue) ? "redHighlightPredict" : "red")}`);
            $("#" + matchKey + "-sb").attr('class', `${((predictedRed < predictedBlue) ? "blueHighlightPredict" : "blue")}`);
        }
    }

    function updateEventStatus(eventState, matches, scheduleOffset) {
        let eventStatus = "";
        if (eventState == "Past") {
            eventStatus = "Event is complete (<a href='#Playoffs'>playoffs</a>)";// "/ <a href='#Brackets'>brackets</a>)";
        } else if (eventState == "Future") {
            eventStatus = "Match schedule not yet available";
        } else {
            if (eventState == "Qualifications" && matches[0].alliances["red"].score == -1) {
                eventStatus = "Qualifications haven't started";
            }
            @{/*
            else if (eventState == "Qualifications" && Model.TBAMatches.Count(m => m.comp_level == "qm" && m.score_breakdown == null) == 0) {
                eventStatus = "Qualifications have completed - waiting for playoffs to begin";
                if (matches[matches.length-1].comp_level == "sf") {
                    eventStatus += "<span>(<a href='#nextmatch'>next match</a>)</span>";
                }
            }
            */}
            else if (eventState == "Qualifications" || eventState == "Playoffs" || eventState == "Finals") {
                scheduleOffset = Math.floor(scheduleOffset);
                if (scheduleOffset == 0) {
                    eventStatus = `${eventState} seem to be running on time (<a href='#nextmatch'>next match</a>)`;
                }
                else {
                    let offsetColor = (scheduleOffset > 0 ? "#7c0a0a" : "#046705");
                    let offsetBehindAhead = (scheduleOffset > 0 ? "behind" : "ahead");
                    eventStatus = `<span style='font-style:italic; color:${offsetColor};'>${eventState} are running about ${Math.abs(scheduleOffset)} minute${(Math.abs(scheduleOffset) > 1 ? "s" : "")} ${offsetBehindAhead} (<a href='#nextmatch'>next match</a>)</span>`;
                }
            }
        }

        $("#eventStatus").html(eventStatus);
    }

    function updateMatchTime(match, eventState, scheduleOffset) {
        let matchTime = "";
        var matchKey = match.competitionLevel + match.setNumber.toString().padStart(2, '0') + match.matchNumber.toString().padStart(3, '0');
        let schedTime = new Date(match.timeScheduledUnix * 1000);
        let weekDays = { 0: 'Sun', 1: 'Mon', 2: 'Tue', 3: 'Wed', 4: 'Thu', 5: 'Fri', 6: 'Sat', 7: 'Sun' };
        let dayOfWeek = schedTime.getDay();
        if (match.hasStarted) {
            let actualTime = new Date(match.timeActualUnix * 1000);
            matchTime = `<span>${weekDays[dayOfWeek]} ${schedTime.format("M/d")} ${schedTime.format("h:mm")} (${actualTime.format("h:mm")})</span>`;
        }
        else if (eventState != "Future")
        {
            let offset = scheduleOffset;
            if (schedTime > new Date()) { offset = 0; }
            let estTime = new Date((match.timeScheduledUnix + offset * 60) * 1000);
            matchTime = `<span>${weekDays[dayOfWeek]} ${schedTime.format("M/d")} ${schedTime.format("h:mm")} <i>(est. ${estTime.format("h:mm")})</i></span>`;
        }

        $("#" + matchKey + "-time").html(matchTime);
    }

    Date.prototype.format = function (formatString) {
        return Object.entries({
            M: this.getMonth() + 1,
            DDD: this.toLocaleDateString('default', { weekday: 'short' }),
            d: this.getDate(),
            h: (this.getHours() % 12 > 0 ? this.getHours() % 12 : 12).toString(),
            mm: this.getMinutes().toString().padStart(2, '0'),
        }).reduce((acc, entry) => {
            return acc.replace(entry[0], entry[1].toString())
        }, formatString)
    }

    function processFilter() {
        var teamnumber = $('#filterValue').val();
        if (teamnumber == "") {
            resetFilter();
            return;
        }
        $('#tableMatches > tbody  > tr').each(function () {
            var showRow = false;
            var targetID = $(this).attr('id');
            if (targetID && targetID.slice(-2) === "-r") {
                $("td > div[id^=tm] > span[id^=tmNum]", this).each(function () {
                    var m = $(this).text().trim();
                    if (m == teamnumber) {
                        showRow = true;
                    }
                });
                if (!showRow)
                    $(this).hide();
                else
                    $(this).show();
                showRow = false;
            }
        });
    }

    function resetFilter() {
        $('#tableMatches > tbody  > tr').each(function () {
            var targetID = $(this).attr('id');
            if (targetID) {
                $('#' + targetID).show();
            }
        });
        $("#filterValue").val('');
    }

    setInterval(updateEventData, 10000);

    function showDialog(message) {
        $("#prediction").html(message);
        const dialog = document.getElementById("predictionDialog");
        dialog.showModal();
    }
</script>
